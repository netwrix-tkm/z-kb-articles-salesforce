<?xml version="1.0" encoding="UTF-8"?><html><head><meta charset="utf-8"/><title>Explanation of Memory Stats in FSAA Applet Logs</title><meta name="label" content="employees_v"/><meta name="label" content="skb"/><meta name="KnowledgeArticleId" content="kA04u0000000IuZCAU"/><meta name="Id" content="ka04u000000HcyMAAS"/><meta name="LastPublishedDate" content="2022-02-01T18:40:49.000+0000"/><meta name="LastModifiedDate" content="2023-05-08T10:12:32.000+0000"/><meta name="FirstPublishedDate" content="2022-02-01T18:40:49.000+0000"/><meta name="Language" content="en_US"/><meta name="UrlName" content="7310"/><meta name="ArticleNumber" content="000007310"/><meta name="description" content="360008408371"/></head><body><article class=" kb-articles"><div class="Content__c"><p><strong><span class="wysiwyg-font-size-large">Summary:</span></strong> Explains metrics logged by FSAA to track memory allocation over the course of a scan</p>
<p><strong><span class="wysiwyg-font-size-large">Issue:</span></strong> In situations where processes appear to be taking up a significant amount of space in RAM, it's sometimes difficult to tell if that's problematic or expected. This KB shows one analysis based on extracted memory allocation log messages and explains terminology for each part of the message logged. In this case study, the customer's file server ran out of paged pool memory during a scan. They wanted reassurance either that it wouldn't happen again, or that we had done our due diligence in understanding the root cause to the best of our ability.</p>
<p><strong><span class="wysiwyg-font-size-large">Instructions:</span></strong> PowerShell was used to extract statistics from applet log, which were then manually scrubbed using Find/Replace in a text editor and/or Excel. This could be further automated if necessary. The commands users were as follows:<br/> <br/><span><span><span>$log</span></span></span><span><span><span>=</span></span></span><span><span><span>'C:\fsaa_appletLog.txt'</span></span></span><br/><span><span><span>select-string</span></span></span><span><span> <span>-path</span> <span>$log</span> <span>-pattern</span> <span>"TotalAddressS</span></span></span><span><span><span>pace"</span> <span>|</span> <span>select</span> <span>line</span> <span>|</span> <span>export-csv</span> <span>C:\fsaa_stats.tsv</span> <span>-delimiter</span> <span>"`t"</span> <span>-NoTypeInformation</span></span></span><br/> <br/>The following screen shot of excel shows the details of the memory usages by the StealthAUDIT process with a graph.<br/><br/><img src="kA04u0000000IuZCAU_11b7a9f8-e8d5-49f6-ac9d-70a4916a2cea.png" alt="mceclip0.png"/> <br/><br/>The Excel file is located here: \\sbitsinc.com\public\Escalation\KB Attachments\Explanation-of-Memory-Stats-in-FSAA-Applet-Logs\AppletLog_MemoryAllocation.xlsx<br/><br/>The key part to notes of the analysis which is two-fold:</p>
<ol><li><span>Our process seems to use relatively the same amount of RAM from the time it ramps up until the time that logging ended (as a result of the scan finishing or or the system going down due to insufficient paged-pool memory.</span></li><li><span>The amount of RAM it was using was under what was allocated to it as it shows free memory in the TotalFree column.</span></li></ol>
<p>Column details:<br/><strong>TotalAddressSpace:</strong> Most amount of memory, in bytes, the 32 bit process can take up<br/><strong>TotalCommitted:</strong> The operating system guarantees that the corresponding pages for the number of bytes listed could in principle exist either in physical RAM or on the page file. In other words, it counts toward its hard limit of total available pages on the system, and it formally creates pages. That is, it creates pages and pretends that they exist (when in reality they don't exist yet).<br/><strong>TotalUncommitted: </strong>Opposite of the committed memory, memory, in bytes, that can't be guaranteed to exist through pre-allocation<br/><strong>TotalAllocated:</strong> How much memory, in bytes, is currently being utilized by the process<br/><strong>TotalFree:</strong> How much memory, in bytes, is free for the process to use<br/> <br/>The first and simplest way to watch for a problem is to watch task manager to see where the ram grows and what processes may be using it. See the attached screen shot of the fields to monitor:<br/> <br/>Next, this blog post describes more complex ways of getting to the bottom of where specifically the problem lies which include PerfMon counters:<br/><a href="https://blogs.technet.microsoft.com/markrussinovich/2009/03/10/pushing-the-limits-of-windows-paged-and-nonpaged-pool/" target="_blank">https://blogs.technet.microsoft.com/markrussinovich/2009/03/10/pushing-the-limits-of-windows-paged-and-nonpaged-pool/</a><br/> <br/>PerfMon counters that you may want to try and setup before we start the process again:</p>
<ul><li>Pool nonpaged bytes</li><li>Pool paged bytes (virtual size of paged pool - some may be paged out)</li><li>Pool paged resident bytes (physical size of paged pool)</li></ul>
<p> <br/>You can get even more granular, as the blog post describes more sophisticated ways to track memory leaks with other utilities, and dump files to obtain sub process level details.<br/> </p>
<p><strong><span class="wysiwyg-font-size-large">Product:</span></strong> StealthAUDIT<br/><strong><span class="wysiwyg-font-size-large">Module:</span></strong> SA - DC - FSAA - Activity;SA - DC - FSAA - DFS;SA - DC - FSAA - Permissions;SA - DC - FSAA - Sensitive Data<br/><strong><span class="wysiwyg-font-size-large">Versions:</span></strong> 6.3, 7.0, 7.1, 7.2<br/><strong><span class="wysiwyg-font-size-large">Dev Ticket:</span></strong> SAFS-1307<br/><strong><span class="wysiwyg-font-size-large">Legacy Article ID:</span></strong> 1313</p></div>
</article></body></html>